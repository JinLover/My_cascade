import * as vscode from 'vscode';
import { IAIService } from '../ai/IAIService';

export class CompletionProvider implements vscode.CompletionItemProvider {
    private aiService: IAIService;

    constructor(aiService: IAIService) {
        this.aiService = aiService;
    }

    async provideCompletionItems(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken,
        context: vscode.CompletionContext
    ): Promise<vscode.CompletionItem[] | undefined> {
        try {
            // Get the current line text up to the cursor
            const linePrefix = document.lineAt(position).text.substr(0, position.character);
            
            // Skip if the line is empty or only whitespace
            if (!linePrefix.trim()) {
                return undefined;
            }

            // Get the surrounding code context (previous few lines)
            const startLine = Math.max(0, position.line - 5);
            const contextRange = new vscode.Range(
                new vscode.Position(startLine, 0),
                position
            );
            const codeContext = document.getText(contextRange);

            // Get AI suggestion
            const suggestion = await this.aiService.processCodeChanges(codeContext, true);
            
            if (suggestion && typeof suggestion === 'string') {
                const completionItem = new vscode.CompletionItem(suggestion, vscode.CompletionItemKind.Snippet);
                completionItem.detail = 'AI Suggestion';
                completionItem.documentation = new vscode.MarkdownString('Generated by AI');
                
                // Remove any common indentation from the suggestion
                const lines = suggestion.split('\n');
                const indent = lines[0].match(/^\s*/)?.[0] || '';
                const cleanedSuggestion = lines.map(line => line.replace(new RegExp(`^${indent}`), '')).join('\n');
                
                completionItem.insertText = new vscode.SnippetString(cleanedSuggestion);
                completionItem.range = new vscode.Range(
                    new vscode.Position(position.line, position.character - linePrefix.trimLeft().length),
                    position
                );
                
                return [completionItem];
            }
        } catch (error) {
            console.error('Error providing completion:', error);
        }
        return undefined;
    }
}

export class CompletionManager {
    private aiService: IAIService;
    private disposables: vscode.Disposable[] = [];

    constructor(aiService: IAIService) {
        this.aiService = aiService;
        this.initialize();
    }

    private initialize() {
        // Register the completion provider for multiple languages
        const supportedLanguages = [
            'typescript',
            'javascript',
            'python',
            'java',
            'cpp',
            'csharp',
            'php',
            'ruby',
            'go',
            'rust'
        ];

        this.disposables.push(
            ...supportedLanguages.map(language =>
                vscode.languages.registerCompletionItemProvider(
                    { scheme: 'file', language: language },
                    new CompletionProvider(this.aiService),
                    '.', '(', '{', '[', ':', ';', ' ' // Trigger characters
                )
            )
        );
    }

    public updateAIService(aiService: IAIService) {
        this.aiService = aiService;
    }

    public dispose() {
        this.disposables.forEach(d => d.dispose());
    }
} 